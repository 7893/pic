# 001. 核心架构决策 (Architecture Decisions)

**日期**: 2026-02-16
**状态**: 已采纳

## 1. 为什么选择 D1 而不是 KV?

**背景**:
我们需要存储图片元数据（宽/高、描述、摄影师信息）。Cloudflare Workers KV 是简单的键值对存储，而 D1 是基于 SQLite 的关系型数据库。

**决策**:
选择 **D1 (SQLite)**。

**理由**:
1.  **查询能力**: 我们需要按 `created_at` 排序、按 `width` 过滤等复杂查询，KV 无法胜任。
2.  **事务支持**: 在 Workflow 中，我们需要确保元数据写入和向量索引的一致性，D1 支持事务 (ACID)。
3.  **成本**: D1 的读写配额对于此规模的应用完全足够，且无需额外付费。

## 2. 为什么引入 Vectorize (向量数据库)?

**背景**:
旧版仅支持简单的标签匹配 (Tag Matching)。这种方式无法理解“悲伤的雨天”这种抽象概念。

**决策**:
引入 **Vectorize** 配合 **Workers AI (Embedding)**。

**理由**:
1.  **语义理解**: 用户可以用自然语言搜图，大大提升体验。
2.  **原生集成**: Vectorize 与 Worker 代码无缝集成，无需额外部署 Milvus/Pinecone 等重型服务。
3.  **即时索引**: 每次新图入库，毫秒级即可被搜索到。

## 3. 为什么选择 Hono 框架?

**背景**:
旧版使用原生 `fetch` 处理路由，代码冗长且难以维护 (`if url === ...`)。

**决策**:
后端全面迁移至 **Hono**。

**理由**:
1.  **路由清晰**: 类似于 Express/Koa 的路由定义 (`app.get('/search', ...)`).
2.  **类型安全**: Hono 对 TypeScript 支持极佳，配合 Zod 可以实现运行时参数校验。
3.  **中间件**: 支持 Cors, Auth, Logger 等中间件，无需手写。
4.  **轻量级**: 包体积极小，不会导致 Worker 启动变慢。

## 4. 为什么采用 Monorepo?

**背景**:
项目涉及 API 后端、处理后端 (Processor) 和前端 (Web) 三个部分，它们共享数据模型定义。

**决策**:
使用 **Monorepo** 结构。

**理由**:
1.  **代码复用**: `packages/shared` 可以定义统一的 TypeScript 接口，确保前后端契约一致。
2.  **统一依赖**: `package.json` 统一管理依赖版本，避免版本冲突。
3.  **原子提交**: 一次 Commit 可以同时修改 API 和 Frontend，保证功能完整性。

## 5. 为什么使用 Terraform 管理基础设施?

**背景**:
Cloudflare 资源（D1, R2, Queue）可以通过 `wrangler` 命令行创建，但这种方式是命令式的，缺乏状态管理和可复现性。

**决策**:
采用 **Terraform** 进行声明式基础设施管理 (IaC)。

**理由**:
1.  **可复现性**: `main.tf` 明确定义了所有资源，任何人都可以在新环境中一键拉起整套系统。
2.  **状态管理**: Terraform State (`.tfstate`) 跟踪资源状态，避免重复创建或配置漂移。
3.  **标准化**: 相比 `wrangler` 的多命令操作，Terraform 是业界通用的基础设施管理标准。
