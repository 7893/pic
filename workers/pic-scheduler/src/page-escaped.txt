<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å›¾ç‰‡ä¸‹è½½å™¨</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 1rem;
    }
    .container { 
      max-width: 1200px; 
      margin: 0 auto;
    }
    h1 { 
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: 600;
      margin-bottom: 2rem;
      color: white;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card { 
      background: white;
      border-radius: 12px;
      padding: clamp(1rem, 3vw, 2rem);
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .limit-info { 
      font-size: clamp(0.75rem, 2vw, 0.875rem);
      color: #666;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }
    .limit-warning { color: #dc3545; font-weight: 600; }
    .limit-ok { color: #28a745; font-weight: 600; }
    .controls { 
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    input { 
      flex: 1;
      min-width: 120px;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      transition: border-color 0.3s;
    }
    input:focus { 
      outline: none;
      border-color: #667eea;
    }
    button { 
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      white-space: nowrap;
    }
    button:hover:not(:disabled) { 
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    button:disabled { 
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .btn-primary { background: #667eea; color: white; }
    .btn-danger { background: #dc3545; color: white; }
    .btn-warning { background: #fd7e14; color: white; }
    .progress-section { margin-top: 1rem; }
    .progress-item { margin-bottom: 0.75rem; }
    .progress-label { 
      font-size: 0.875rem;
      color: #666;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
    }
    .progress-bar { 
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-fill { 
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s;
      border-radius: 4px;
    }
    .stats-grid { 
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .stat-card { 
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .stat-title { 
      font-size: 0.75rem;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 0.5rem;
    }
    .stat-value { 
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #667eea;
      margin-bottom: 0.25rem;
    }
    .stat-sub { 
      font-size: 0.875rem;
      color: #666;
    }
    .category-item { 
      display: flex;
      justify-content: space-between;
      padding: 0.75rem 0;
      border-bottom: 1px solid #f0f0f0;
    }
    .category-item:last-child { border-bottom: none; }
    .category-name { 
      font-size: 0.875rem;
      color: #333;
      font-weight: 500;
    }
    .category-count { 
      font-size: 0.875rem;
      color: #667eea;
      font-weight: 600;
    }
    @media (max-width: 768px) {
      .controls { flex-direction: column; }
      button { width: 100%; }
      .stats-grid { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 480px) {
      .stats-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ“· å›¾ç‰‡ä¸‹è½½å™¨</h1>
    
    <div class="card">
      <div class="limit-info">
        <div style="margin-bottom: 0.5rem;">ğŸ“Š API é™åˆ¶ï¼šæ¯å°æ—¶ 50 æ¬¡è¯·æ±‚ | æ¯é¡µ 30 å¼  | æœ€å¤š 10 é¡µ (300 å¼ )</div>
        <div id="limitStatus">æ£€æŸ¥ä¸­...</div>
      </div>
      
      <div class="controls">
        <input type="number" id="count" value="30" min="1" max="300" placeholder="ä¸‹è½½æ•°é‡">
        <button onclick="startDownload()" id="downloadBtn" class="btn-primary">å¼€å§‹ä¸‹è½½</button>
        <button onclick="stopDownload()" id="stopBtn" class="btn-danger" style="display:none;">åœæ­¢ä¸‹è½½</button>
        <button onclick="clearImages()" id="clearBtn" class="btn-warning">æ¸…é™¤å›¾ç‰‡</button>
      </div>
      
      <div class="progress-section" id="progressSection" style="display:none;">
        <div class="progress-item">
          <div class="progress-label">
            <span>å½“å‰å›¾ç‰‡</span>
            <span id="currentProgress">0/0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="currentFill"></div>
          </div>
        </div>
        <div class="progress-item">
          <div class="progress-label">
            <span>æœ¬æ‰¹è¿›åº¦</span>
            <span id="batchProgress">0/0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="batchFill"></div>
          </div>
        </div>
        <div class="progress-item">
          <div class="progress-label">
            <span>æ€»è®¡è¿›åº¦</span>
            <span id="totalProgress">0</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="totalFill"></div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-title">æ€»ä¸‹è½½é‡</div>
        <div class="stat-value" id="totalImages">0</div>
        <div class="stat-sub">å¼ å›¾ç‰‡</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">å­˜å‚¨å®¹é‡</div>
        <div class="stat-value" id="totalSize">0</div>
        <div class="stat-sub">MB</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">API è°ƒç”¨</div>
        <div class="stat-value" id="apiCalls">0</div>
        <div class="stat-sub" id="apiRate">æˆåŠŸç‡ 0%</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">å¹³å‡å°ºå¯¸</div>
        <div class="stat-value" id="avgResolution">0</div>
        <div class="stat-sub">MB/å¼ </div>
      </div>
    </div>
    
    <div class="card">
      <div class="stat-title" style="margin-bottom: 1rem;">åˆ†ç±»ç»Ÿè®¡</div>
      <div id="categoryList"></div>
    </div>
  </div>
  
  <script>
    let downloading = false;
    let progressInterval;
    let currentApiUsage = 0;
    let maxApiLimit = 50;
    let currentTaskId = null;
    
    async function checkApiLimit() {
      try {
        const response = await fetch('/api-limit');
        const data = await response.json();
        currentApiUsage = data.used;
        const remaining = maxApiLimit - currentApiUsage;
        const resetTime = new Date(data.resetAt).toLocaleTimeString('zh-CN', { timeZone: 'Asia/Hong_Kong' });
        
        const limitStatus = document.getElementById('limitStatus');
        const downloadBtn = document.getElementById('downloadBtn');
        const countInput = document.getElementById('count');
        
        if (remaining <= 0) {
          limitStatus.innerHTML = '<span class="limit-warning">âš ï¸ å·²è¾¾åˆ°é™åˆ¶ (50/50)ï¼Œé‡ç½®æ—¶é—´: ' + resetTime + '</span>';
          if (!downloading) downloadBtn.disabled = true;
          countInput.disabled = true;
        } else if (remaining <= 10) {
          limitStatus.innerHTML = '<span class="limit-warning">âš ï¸ å‰©ä½™è¯·æ±‚: ' + remaining + '/50ï¼Œé‡ç½®æ—¶é—´: ' + resetTime + '</span>';
          countInput.max = Math.min(300, remaining * 30);
          if (!downloading) downloadBtn.disabled = false;
          countInput.disabled = false;
        } else {
          limitStatus.innerHTML = '<span class="limit-ok">âœ“ å‰©ä½™è¯·æ±‚: ' + remaining + '/50ï¼Œé‡ç½®æ—¶é—´: ' + resetTime + '</span>';
          countInput.max = 300;
          if (!downloading) downloadBtn.disabled = false;
          countInput.disabled = false;
        }
      } catch (e) {
        console.error('Failed to check API limit:', e);
      }
    }
    
    async function startDownload() {
      if (downloading) return;
      const count = parseInt(document.getElementById('count').value);
      
      if (count < 1 || count > 300) {
        alert('è¯·è¾“å…¥ 1-300 ä¹‹é—´çš„æ•°é‡');
        return;
      }
      
      const pagesNeeded = Math.ceil(count / 30);
      const remaining = maxApiLimit - currentApiUsage;
      if (pagesNeeded > remaining) {
        alert('éœ€è¦ ' + pagesNeeded + ' æ¬¡è¯·æ±‚ï¼Œä½†åªå‰©ä½™ ' + remaining + ' æ¬¡');
        return;
      }
      
      downloading = true;
      document.getElementById('downloadBtn').disabled = true;
      document.getElementById('stopBtn').style.display = 'inline-block';
      document.getElementById('clearBtn').disabled = true;
      document.getElementById('count').disabled = true;
      document.getElementById('progressSection').style.display = 'block';
      
      try {
        const response = await fetch('/download', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ count })
        });
        
        const result = await response.json();
        if (result.success) {
          currentTaskId = result.taskId;
          progressInterval = setInterval(updateProgress, 500);
        } else {
          alert('é”™è¯¯: ' + result.error);
          resetUI();
        }
      } catch (e) {
        alert('é”™è¯¯: ' + e.message);
        resetUI();
      }
    }
    
    async function stopDownload() {
      if (!currentTaskId) return;
      
      if (!confirm('ç¡®å®šè¦åœæ­¢ä¸‹è½½å—ï¼Ÿ')) {
        return;
      }
      
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('stopBtn').textContent = 'åœæ­¢ä¸­...';
      
      try {
        await fetch('/stop?taskId=' + currentTaskId, { method: 'POST' });
        clearInterval(progressInterval);
        resetUI();
        checkApiLimit();
        loadStats();
      } catch (e) {
        console.error('Failed to stop:', e);
        alert('åœæ­¢å¤±è´¥: ' + e.message);
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('stopBtn').textContent = 'åœæ­¢ä¸‹è½½';
      }
    }
    
    async function clearImages() {
      if (downloading) {
        alert('è¯·å…ˆåœæ­¢ä¸‹è½½');
        return;
      }
      
      if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å›¾ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
        return;
      }
      
      document.getElementById('clearBtn').disabled = true;
      document.getElementById('clearBtn').textContent = 'æ¸…é™¤ä¸­...';
      
      try {
        const response = await fetch('/clear', { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
          alert('å·²æ¸…é™¤ ' + result.deleted + ' å¼ å›¾ç‰‡');
          loadStats();
        } else {
          alert('æ¸…é™¤å¤±è´¥: ' + result.error);
        }
      } catch (e) {
        alert('æ¸…é™¤å¤±è´¥: ' + e.message);
      } finally {
        document.getElementById('clearBtn').disabled = false;
        document.getElementById('clearBtn').textContent = 'æ¸…é™¤å›¾ç‰‡';
      }
    }
    
    function resetUI() {
      downloading = false;
      currentTaskId = null;
      document.getElementById('downloadBtn').disabled = false;
      document.getElementById('stopBtn').style.display = 'none';
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('stopBtn').textContent = 'åœæ­¢ä¸‹è½½';
      document.getElementById('clearBtn').disabled = false;
      document.getElementById('count').disabled = false;
      document.getElementById('progressSection').style.display = 'none';
    }
    
    async function updateProgress() {
      if (!currentTaskId) return;
      
      try {
        const response = await fetch('/progress?taskId=' + currentTaskId);
        const data = await response.json();
        
        const currentPct = data.total > 0 ? (data.current / data.total * 100) : 0;
        const batchPct = data.batchTotal > 0 ? (data.batchCurrent / data.batchTotal * 100) : 0;
        
        document.getElementById('currentProgress').textContent = data.current + '/' + data.total;
        document.getElementById('currentFill').style.width = currentPct + '%';
        
        document.getElementById('batchProgress').textContent = data.batchCurrent + '/' + data.batchTotal;
        document.getElementById('batchFill').style.width = batchPct + '%';
        
        document.getElementById('totalProgress').textContent = data.totalDownloaded + ' å¼ ';
        document.getElementById('totalFill').style.width = Math.min(100, (data.totalDownloaded / 100) * 100) + '%';
        
        if (data.current >= data.total && data.total > 0) {
          clearInterval(progressInterval);
          resetUI();
          checkApiLimit();
          loadStats();
        }
      } catch (e) {
        console.error('Failed to update progress:', e);
      }
    }
    
    async function loadStats() {
      try {
        const response = await fetch('/stats');
        const data = await response.json();
        
        document.getElementById('totalImages').textContent = data.totalImages || 0;
        document.getElementById('totalSize').textContent = data.totalSize || '0';
        document.getElementById('apiCalls').textContent = data.apiCalls || 0;
        document.getElementById('apiRate').textContent = 'æˆåŠŸç‡ ' + (data.successRate || '0%');
        document.getElementById('avgResolution').textContent = data.avgResolution || '0';
        
        const categoryList = document.getElementById('categoryList');
        if (data.categories && data.categories.length > 0) {
          categoryList.innerHTML = data.categories.map(c => 
            '<div class="category-item"><span class="category-name">' + c.category + '</span><span class="category-count">' + c.count + ' å¼ </span></div>'
          ).join('');
        } else {
          categoryList.innerHTML = '<div class="category-item"><span class="category-name">æš‚æ— æ•°æ®</span></div>';
        }
      } catch (e) {
        console.error('Failed to load stats:', e);
      }
    }
    
    checkApiLimit();
    loadStats();
    setInterval(checkApiLimit, 5000);
    setInterval(loadStats, 10000);
  </script>
</body>
</html>
